## 정리 내용
### 다이나믹 프로그래밍이란
- Dynamic Programing, `동적 계획법`이라고도 표현한다.
- 한 번 계산한 문제는 다시 계산하지 않도록 중복된는 연산을 줄이는 알고리즘이다.
- 대표적인 예로 피보나치 수열 문제가 있다.
- 피보나치 수열 문제를 재귀 함수로 구현하면 n이 작을 땐, 상관이 없지만 n이 높으면 수행 시간이 기하급수적으로 늘어나 매우 비효율적이된다.
- 이를 해결하기 위해 다이나믹 프로그래밍을 사용하면 된다.
- **다만, 다이나믹 프로그래밍은 다음 두 조건을 만족시키는 상황에서만 사용할 수 있다.**
1) 큰 문제를 작은 문제로 나눌 수 있다.
2) 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
- 메모이제이션(memoization)은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미한다.
- 메모이제이션은 값을 저장하는 방법이므로 캐싱(caching)이라고도 한다.
- python에서 메모이제이션을 구현하는 방법은 한 번 구한 정보를 리스트에 저장하고 정보가 필요할 때 이미 구한 정답을 그대로 리스트에서 가져오면 된다.
- 다이나믹 프로그래밍에는 2가지 방식이 있다.
1) **top-down: <u>재귀 함수</u>를 이용하여 DP를 작성하는 방법을, 큰 문제를 해결하기 위해 작은 문제를 호출하는 방법.**
2) **bottom-up: <u>반복문</u>을 이용하여 작은 문제부터 차근차근 답을 도출하는 방법.**
- 정리하면, 다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효울적으로 해결하는 알고리즘 기법이다.
- 다이나믹 프로그래밍과 분할 정복의 차이점은 다이나믹 프로그래밍은 문제들이 서로 영향을 미치고 있다는 점이다.
- 가능하다면 탑다운 방식보다는 바텀업 방식으로 구현하는것을 권장한다.

### 피보나치 재귀함수 소스코드
```python
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x-1) + fibo(x-2)
```

### Memoization 기법으로 접근한 피보나치 소스코드 (top-down)
```python
# 한 번 계산된 결과를 memoization하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수를 재귀함수로 구현(top-down dp)
def fibo(x):
    # 종료 조건(1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x-1) + fibo(x-2)
    
    return d[x]

print(fibo(99))
```

### 피보나치 소스코드 (bottom-up)
```python
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수 반복문으로 구현(bottom-up)
for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]

print(d[n])
```

## 출처 & 깃허브
[이것이 취업을 위한 코딩 테스트다 with python](http://www.yes24.com/Product/Goods/91433923)

[github](https://github.com/KYUSEONGHAN/python-for-coding-test)